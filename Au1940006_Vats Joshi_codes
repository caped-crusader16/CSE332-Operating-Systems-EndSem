Question 1
#include <stdlib.h>
#include <stdio.h>
#include <pthread.h>

pthread_mutex_t mutex;
int i=1;
char c='A'
char r=’a’
void pattern(){
    pthread_mutex_lock(&mutex);
    printf(%d, c);
    printf(%c, z);
    printf(%r, r);
    cout<<'\n';
    z++;
    c++;
    r++;
    pthread_mutex_unlock(&mutex);   
}

int main(int argc, char* argv[]) {
    pthread_t thread[25];
    int j;
    pthread_mutex_init(&mutex, NULL);
    for (j = 0; j < 25; i++) {
        if (pthread_create(thread + j, NULL, &pattern, NULL) != 0) {
            perror("Failed to create thread");
            return 1;
        }
    }
    for (j = 0; j < 25; i++) {
        if (pthread_join(thread[j], NULL) != 0) {
            return 2;
        }
    }
    pthread_mutex_destroy(&mutex);
    return 0;
}

Question 2

#include<stdio.h>
int main() {
   int proc[] = {1, 2, 3, 4, 5};
   int n = 5
   int burst_time[] = {5, 8, 12, 20, 22};
   int arrival_time[]={0,1,2,2,4}   
   int temp[10];
   int i;
   int sum=0,count=0;
   int waittime=0,turntime=0,
   int tquant=1;

 for(sum=0, i = 0; n!=0; )  
 {  
 if(temp[i] <= tquant && temp[i] > 0)  
 {  
    sum = sum + temp[i];  
    temp[i] = 0;  
    count=1;  
    }     
    else if(temp[i] > 0)  
    {  
        temp[i] = temp[i] - tquant;  
        sum = sum + tquant;    
    }  
    if(temp[i]==0 && count==1)  
    {  
        n--;  
        waittime = waittime+sum-arrival_time[i]-burst_time[i];  
        turntime = turntime+sum-arrival_time[i];  
        count =0;     
    }  
    if(i==n-1)  
    {  
        i=0;  
    }  
    else if(arrival_time[i+1]<=sum)  
    {  
        i++;  
    }  
    else  
    {  
        i=0;  
    }  
 }
}

Question 3

//semaphores describe the empty and full buffers and mutexes are used to hold the function until all the two commands to fill the buffer are not executed.
#include <pthread.h>
#include <semaphore.h>
#include <stdlib.h>
#include <stdio.h>
#define MaxItems  n
#define BufferSize  z
#define THREAD_NUM 8
sem_t empty; //used for performing semaphore operations
sem_t full;   //used for performing semaphore operations
int in = 0;
int out = 0;
int buffer[BufferSize];
pthread_mutex_t mutex;

void *producer()
{
int item;
for(int i = 0; i < MaxItems; i++) {
item = 1;
sem_wait(&empty);  
pthread_mutex_lock(&mutex);
buffer[in] = item;
in = (in+1)%BufferSize;
pthread_mutex_unlock(&mutex);
sem_post(&full);
}
}
void *consumer()
{
for(int i = 0; i < MaxItems; i++) {
sem_wait(&full); 
pthread_mutex_lock(&mutex);
int item = buffer[out];
out = (out+1)%BufferSize;
pthread_mutex_unlock(&mutex);
sem_post(&empty);
}
}
int main(int argc, char* argv[])
{
pthread_t th[THREAD_NUM];
    pthread_mutex_init(&mutexBuffer, NULL);
    sem_init(&semEmpty, 0, BufferSize);
    sem_init(&semFull, 0, 0);
    int i;
    for (i = 0; i < THREAD_NUM; i++) {
        if (i > 0) {
            if (pthread_create(&th[i], NULL, &producer, NULL) != 0) {
                perror("Failed ");
            }
        } else {
            if (pthread_create(&th[i], NULL, &consumer, NULL) != 0) {
                perror("Failed");
            }
        }
    }
    for (i = 0; i < THREAD_NUM; i++) {
        if (pthread_join(th[i], NULL) != 0) {
            perror("Failed to join thread");
        }
    }
    sem_destroy(&semEmpty);
    sem_destroy(&semFull);
    pthread_mutex_destroy(&mutexBuffer);
    return 0;
}

